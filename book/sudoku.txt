row0 = [1,2,3,4]
row1 = row0[2:4] + row0[0:2]
row2 = [row0[1], row0[0], row0[3], row0[4]]
row3 = row2[2:4] + row2[0:2]
board = [row0, row1, row2, row3]


[1,2,3,4]
[3,4,1,2]
[2,1,4,3]
[4,3,2,1]


board = [[1,2,3,4],[3,4,1,2],[2,1,4,3],[4,3,2,1]]


[[1,2,3,4],
[5,6,7,8],
[9,10,11,12],
[13,14,15,16]]


[[],[],[],[]]


[[1],
[2],
[3],
[4]]


[[1,5],
[2,6],
[3,7],
[4,8]]


[[1,5,9],
[2,6,10],
[3,7,11],
[4,8,12]]


[[1,5,9,13],
[2,6,10,14],
[3,7,11,15],
[4,8,12,16]]



4x4 미니 스도쿠 구현 알고리즘

1. 무작위로 스도쿠 정답보드 solution_board 만들기
2. solution_board를 복제하여 puzzle_board 하나 만들기
3. 사용자에게 난이도를 선택하게 하여 빈칸의 개수 no_of_holes 정하기
4. puzzle_board에 no_of_holes만큼 무작위로 선택하여 0으로 채우기
5. puzzle_board를 실행창에 정한 형식대로 보여주기 실행창에선 빈칸을 '.'(점)으로 표시
6. 다음 절차를 no_of_holes가 0이 될 때까지 반복
(a) 숫자를 채울 빈칸의 가로줄번호 i, 세로줄번호 j를 차례로 입력
(b) (i,j) 위치에 있는 숫자가 0이 아니면 빈칸이 아니므로 재입력
(c) 빈칸이면 숫자(1,2,3,4) n을 입력
(d) n이 solution_board[i][j]와 같으면 puzzle_board[i][j]에 그 숫자를 채우고, 갱신한 puzzle_board를 보여줌
(e) 이 숫자가 solution_board[i][j]와 다르면, 줄 번호부터 모두 다시 재입력 받기

tip
퍼즐 보드는 경우에 따라서 두 개 이상의 정답이 있을 수 있다.
따라서 정답을 고정시켜 놓고 비교하는 이 알고리즘은 다른 정답을 배제할 수 있어 완벽하지 않다.

